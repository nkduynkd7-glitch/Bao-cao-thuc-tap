# BÁO CÁO KỸ THUẬT: TRIỂN KHAI HỆ THỐNG LOAD BALANCING & HIGH AVAILABILITY (HA)

## 1. Tổng quan mô hình
Hệ thống được thiết kế để đảm bảo tính sẵn sàng cao (High Availability) cho dịch vụ Web, sử dụng **Keepalived** để quản lý IP ảo và **HAProxy** để điều phối lưu lượng.

### Thông số cấu hình:
* **Virtual IP (VIP):** `172.16.20.100`
* **Node 1 (VM1):** `172.16.20.70` (Dịch vụ: Apache @8081)
* **Node 2 (VM2):** `172.16.20.71` (Dịch vụ: Apache @8081 + HAProxy @80)
* **Web_server (VM4):** `172.16.20.74` (Web server)

---

## 2. Các bước triển khai chi tiết

### Bước 1: Khởi tạo dịch vụ Web (Apache)
Thực hiện trên cả hai máy để chuẩn bị backend cho HAProxy.

```yaml
# Cài đặt Apache
sudo apt update && sudo apt install -y apache2

# Đổi cổng lắng nghe sang 8081 để tránh xung đột cổng 80
sudo sed -i 's/Listen 80/Listen 8081/' /etc/apache2/ports.conf
sudo sed -i 's/<VirtualHost \*:80>/<VirtualHost *:8081>/' /etc/apache2/sites-available/000-default.conf

# Tạo nội dung trang chủ phân biệt giữa 2 máy
# Trên VM1:
echo "<h1>Day la VM1 - 172.16.20.70</h1>" | sudo tee /var/www/html/index.html
# Trên VM2:
echo "<h1>Day la VM2 - 172.16.20.71</h1>" | sudo tee /var/www/html/index.html

# Khởi động lại dịch vụ
sudo systemctl restart apache2
```

### Bước 2: Cấu hình High Availability (Keepalived) và tạo Webserver (VM4)
#### 1. Cấu hình High Availability (Keepalived)
Mục tiêu: Đảm bảo IP ảo 172.16.20.100 luôn tồn tại ngay cả khi một Node gặp sự cố.

- Tại VM1 (MASTER):

```yaml
# File: /etc/keepalived/keepalived.conf
vrrp_instance VI_1 {
    state MASTER
    interface eth0          # Kiểm tra bằng lệnh 'ip a'
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1234
    }
    virtual_ipaddress {
        172.16.20.100
    }
}
```

- Tại VM2
Cấu hình tương tự nhưng sửa state BACKUP và priority 90.
```yaml
vrrp_instance VI_1 {
    state BACKUP
    interface eth0           # Thay bằng tên card mạng của bạn
    virtual_router_id 51
    priority 90             # VM2 ưu tiên thấp hơn
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1234
    }
    virtual_ipaddress {
        172.16.20.100        # IP ảo dùng chung
    }
}
```
#### 2. Tạo Webserver
* Bước 1: Chuẩn bị máy ảo Web mới (VM4)
- Cài đặt Web Server: Giả sử VM4 có IP là 172.16.20.74. Bạn cài đặt Nginx
```yaml
sudo apt update && sudo apt install nginx -y
```
- Tạo trang web riêng biệt: Để dễ phân biệt khi test, hãy sửa nội dung trang chủ.
```yaml
echo "<h1>Chào mừng tới Web Server 2 (VM4 - .62)</h1>" | sudo tee /var/www/html/index.html
```
* Bước 2: Cấu hình Web Server chỉ chấp nhận HAProxy (Chốt chặn quan trọng)
- Đây là bước để đáp ứng yêu cầu của sếp: Tắt Proxy là Web phải mất. Thay vì dùng UFW, bạn cấu hình trực tiếp trên Nginx của VM4 để nó chỉ "nói chuyện" với IP của VM1 và VM2.

- Mở file cấu hình mặc định:
```yaml
sudo nano /etc/nginx/sites-available/default
```
- Thêm các dòng allow và deny vào trong block server:
```yaml
server {
    listen 80;
    server_name _;

    # CHỈ CHO PHÉP 2 IP CỦA HAPROXY
    allow 172.16.20.70; # VM1
    allow 172.16.20.71; # VM2
    allow 127.0.0.1;    # Localhost

    # CHẶN TẤT CẢ CÁC IP CÒN LẠI (bao gồm cả IP Public của khách)
    deny all;

    location / {
        try_files $uri $uri/ =404;
    }
}
```
- Kiểm tra và khởi động lại Nginx:
```yaml
sudo nginx -t && sudo systemctl restart nginx
```

### Bước 3: Cấu hình Load Balancing (HAProxy)
Thiết lập HAProxy để nhận yêu cầu tại cổng 80 và chuyển tiếp tới các Backend.
#### Thiết lập ở cả 2 VM
```yaml
# File: /etc/haproxy/haproxy.cfg

frontend http_front
    # Lắng nghe cổng 80 (HTTP) và cổng 443 (HTTPS)
    bind *:80
    # thêm vào sau khi tạo chứng chỉ ở bước 4
    bind *:443 ssl crt /etc/ssl/haproxy/nextcloud.pem

    # Tự động chuyển hướng từ HTTP sang HTTPS để tăng bảo mật
    redirect scheme https if !{ ssl_fc }

    #default_backend web_servers
    default_backend webservers_backend


backend webservers_backend
    mode http
    # Trỏ về máy Nextcloud (.61)
    # Dùng 'ssl verify none' vì ta đang dùng cert nội bộ giữa các máy
    # server nextcloud_srv 172.16.20.61:443 check ssl verify none
    # VM4 chạy Nginx mới (HTTP - nếu bạn chưa cài SSL cho VM4)
    server web_vm4 172.16.20.74:80 check


listen stats
    bind *:8080
    stats enable
    stats uri /stats
    stats auth admin:password123
```

### 4. Quy trình cấp và quản lý chứng chỉ SSL và Thiết lập tự đồng bộ (Automation)
#### 1. Các câu lệnh tạo Chứng chỉ (Thực hiện trên VM1)
Để tạo ra file .pem mà HAProxy yêu cầu, chúng ta thực hiện quy trình 3 bước:

* Bước 1: Tạo Private Key và Certificate Request
Lệnh này sinh ra một cặp khóa và một chứng chỉ có thời hạn 365 ngày:
```yaml
sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
-keyout /etc/ssl/haproxy/nextcloud.key \
-out /etc/ssl/haproxy/nextcloud.crt
```
- x509: Xuất ra chứng chỉ tự ký.

- nodes: Không mã hóa Private Key (để HAProxy có thể tự đọc mà không cần nhập pass mỗi khi khởi động).

- newkey rsa:2048: Tạo khóa RSA với độ dài 2048 bit.

* Bước 2: Tạo file .PEM (Định dạng của HAProxy)
HAProxy yêu cầu cả Cert và Key phải nằm chung trong một file. Chúng ta dùng lệnh cat để gộp chúng lại:
```yaml
cat /etc/ssl/haproxy/nextcloud.crt /etc/ssl/haproxy/nextcloud.key | sudo tee /etc/ssl/haproxy/nextcloud.pem
```

* Bước 3: Phân quyền bảo mật
Vì file .pem chứa khóa bí mật (Private Key), nên cần giới hạn quyền truy cập:
```yaml
sudo chmod 600 /etc/ssl/haproxy/nextcloud.pem
sudo chown haproxy:haproxy /etc/ssl/haproxy/nextcloud.pem
```

#### 2. Cách thức hoạt động của Cert trong mô hình HA
Luồng xác thực:
Trình duyệt khách: Gửi yêu cầu kết nối tới https://172.16.20.100.

HAProxy: Gửi nội dung Public Key trong file nextcloud.pem cho khách.

Mã hóa: Trình duyệt sử dụng Public Key này để mã hóa dữ liệu. Chỉ có HAProxy (giữ Private Key) mới có thể giải mã được dữ liệu này.

Tại sao phải đồng bộ Cert sang VM2?
Như đã trình bày ở phần Automation, việc đồng bộ file .pem sang VM2 là bắt buộc. Nếu VM2 dùng một Cert khác (dù cùng thông tin tên miền), trình duyệt sẽ phát hiện ra Fingerprint (Dấu vân tay) thay đổi và báo lỗi bảo mật ngay lập tức khi hệ thống thực hiện Failover.

#### 3. Cách kiểm tra thông tin Chứng chỉ
Để đưa vào báo cáo minh chứng chứng chỉ đã hoạt động, bạn sử dụng lệnh:

Kiểm tra thời hạn và thông tin người cấp:
```yaml
openssl x509 -in /etc/ssl/haproxy/nextcloud.pem -text -noout
```
Kiểm tra Fingerprint (Để so khớp giữa VM1 và VM2):
```yaml
openssl x509 -noout -fingerprint -sha256 -in /etc/ssl/haproxy/nextcloud.pem
```
#### 4. Thiết lập tự đồng bộ (Automation)
* Bước 1. Thiết lập SSH Passwordless (Từ VM1 sang VM2)
Thực hiện trên VM1:
```yaml
ssh-keygen -t rsa -b 4096 # Nhấn Enter liên tục
ssh-copy-id root@172.16.20.71 # Nhập mật khẩu VM2 lần cuối
```
* Bước 2. Tạo Script đồng bộ trên VM1
- Trước hết xóa các file .pem cũ tránh gây lỗi:
```yaml
sudo rm -f /etc/ssl/haproxy/haproxy.crt /etc/ssl/haproxy/haproxy.key /etc/ssl/haproxy/haproxy.pem
```
Tạo file: sudo nano /usr/local/bin/sync-haproxy.sh:
```yaml
#!/bin/bash
# 1. Đẩy file cấu hình sang VM2
scp /etc/haproxy/haproxy.cfg root@172.16.20.71:/etc/haproxy/
# 2. Đẩy file chứng chỉ SSL sang VM2
scp /etc/ssl/haproxy/nextcloud.pem root@172.16.20.71:/etc/ssl/haproxy/
# 3. Ra lệnh VM2 restart để áp dụng cấu hình mới
ssh root@172.16.20.71 "systemctl restart haproxy"
```
Cấp quyền: 
```yaml
sudo chmod +x /usr/local/bin/sync-haproxy.sh
```
* Bước 3. Cấu hình Systemd tự động kích hoạt
Trên VM1, chạy lệnh:
```yaml
sudo systemctl edit haproxy
```
Dán nội dung sau:
```yaml
[Service]
ExecStartPost=/usr/local/bin/sync-haproxy.sh
```
Nạp lại cấu hình: 
```yaml
sudo systemctl daemon-reload
```
* Bước 4. Test đồng bộ
1. Đồng bộ Config
- Thay đổi trong file config:  nano /etc/haproxy/haproxy.cfg
- Đổi từ **server web_vm4 172.16.20.74:80 check** thành **server web_vm4_update 172.16.20.74:80 check**
<img width="571" height="219" alt="image" src="https://github.com/user-attachments/assets/02bf2a26-2d75-42f8-8187-20914dae7075" />\
- Sau đó lưu file chạy restart và chạy đồng bộ dữ liệu
  ```yaml
  sudo systemctl restart haproxy
  /usr/local/bin/sync-haproxy.sh
  ```
- Kết quả ta thấy file config ở VM2 cũng được thay đổi
<img width="582" height="349" alt="image" src="https://github.com/user-attachments/assets/dfb794e9-46fb-4b59-ba48-d36b4969bf13" />


2. Đồng bộ .pem (Cert)
- Tạo lại Cert ở VM1
<img width="943" height="468" alt="image" src="https://github.com/user-attachments/assets/618f72b0-6c3c-46da-9789-0c0e7552b644" />
- Sau đó lưu file chạy restart và chạy đồng bộ dữ liệu
  ```yaml
  sudo systemctl restart haproxy
  /usr/local/bin/sync-haproxy.sh
  ```
- Cách kiểm tra: Bạn hãy so sánh "dấu vân tay" (Fingerprint) của Certificate trên cả 2 máy để đảm bảo chúng đã khớp nhau:

- Trên VM1: openssl x509 -noout -fingerprint -sha256 -in /etc/ssl/haproxy/nextcloud.pem
<img width="924" height="39" alt="image" src="https://github.com/user-attachments/assets/17701a51-9a96-425e-a1ae-3084ac17ad99" />

- Trên VM2: openssl x509 -noout -fingerprint -sha256 -in /etc/ssl/haproxy/nextcloud.pem
<img width="925" height="35" alt="image" src="https://github.com/user-attachments/assets/0e420e66-e688-4f41-b4b2-3487a2d23f55" />

Kết quả: Nếu 2 dãy mã Hex giống hệt nhau, nghĩa là việc đồng bộ đã thành công.

### 5. Kịch bản kiểm thử & Kết quả
Check trên đường dẫn **http://172.16.20.100:8080/stats**

- user: admin
- pass: password123

<img width="955" height="467" alt="image" src="https://github.com/user-attachments/assets/2e2d9569-21d7-4730-a4f9-afdf765e95e7" />

#### BÁO CÁO KỊCH BẢN KIỂM THỬ: KHẢ NĂNG CHỊU LỖI (FAILOVER)
Mục tiêu: Đảm bảo dịch vụ web vẫn duy trì khi một trong các Proxy bị sập và xác định trạng thái hệ thống khi toàn bộ hạ tầng dự phòng ngừng hoạt động.

1. Trạng thái Ban đầu (Baseline)
VM1 & VM2: Đang chạy HAProxy và Keepalived.

IP ảo (VIP) 172.16.20.100: Đang do VM1 nắm giữ (MASTER).

Trình duyệt: Truy cập https://172.16.20.100 hiển thị nội dung từ Web Server (VM4).

2. Giai đoạn 1: Giả lập VM1 gặp sự cố (Failover sang VM2)
Hành động: Dừng dịch vụ trên VM1 để giả lập sập nguồn.
```yaml
#Thực hiện trên VM1
sudo systemctl stop keepalived
sudo systemctl stop haproxy
```
<img width="338" height="53" alt="image" src="https://github.com/user-attachments/assets/9e2842d1-66b4-47f5-a539-0be0920068ef" />
**Diễn biến kỹ thuật:**

1. Keepalived: VM2 không nhận được gói tin "Heartbeat" từ VM1 sau khoảng 1 giây.

2. Chiếm quyền: VM2 tự động gán IP .100 vào card mạng của chính nó.

3. Duy trì SSL: Trình duyệt khách vẫn kết nối tới .100. VM2 sử dụng file chứng chỉ đã được đồng bộ (nextcloud.pem) để tiếp tục phiên làm việc.

**Kết quả:**

- Truy cập https://172.16.20.100 vẫn hoạt động bình thường.

- Người dùng không nhận thấy sự gián đoạn (Zero Downtime).

<img width="956" height="302" alt="image" src="https://github.com/user-attachments/assets/7fca76c8-b941-43ab-a5d5-9149cf7920a5" />

3. Giai đoạn 2: Giả lập sập toàn bộ lớp Proxy (System Failure)
Hành động: Tiếp tục dừng dịch vụ trên VM2 (Node dự phòng cuối cùng).
```yaml
#Thực hiện trên VM2
sudo systemctl stop keepalived
sudo systemctl stop haproxy
```
<img width="421" height="37" alt="image" src="https://github.com/user-attachments/assets/e17e73d6-ea08-4a4b-8075-80f57a46da90" />

**Diễn biến kỹ thuật:**

Mất VIP: Không còn máy nào trong mạng quảng bá IP .100. IP ảo này biến mất hoàn toàn khỏi mạng.

Kết nối bị ngắt: Trình duyệt không thể tìm thấy máy đích để gửi yêu cầu HTTPS.

**Kết quả:**

Truy cập https://172.16.20.100 báo lỗi: "This site can’t be reached" hoặc "Connection Refused".

<img width="940" height="667" alt="image" src="https://github.com/user-attachments/assets/69767beb-f5f2-45dc-95c6-90d4cb85d46c" />

**Lưu ý quan trọng**: Lúc này Web Server (VM4) vẫn sống, nhưng vì ta đã cấu hình deny all (chỉ cho phép VM1/VM2), nên nếu người dùng cố tình truy cập thẳng IP của VM4 (.74), họ vẫn sẽ nhận lỗi 403 Forbidden. Hệ thống được bảo vệ tuyệt đối.

4. Giai đoạn 3: Khôi phục toàn bộ hệ thống (Recovery)
Hành động: Khởi động lại dịch vụ theo thứ tự ưu tiên.

Bật lại VM2:
```yaml
sudo systemctl start keepalived
sudo systemctl start haproxy
```
Kết quả: Web hoạt động trở lại ngay lập tức (VM2 tạm thời làm Master).

<img width="736" height="150" alt="image" src="https://github.com/user-attachments/assets/60354a8c-ea06-4055-8ec5-287327507e76" />

Bật lại VM1 (Node có Priority cao hơn):
```yaml
sudo systemctl start keepalived
sudo systemctl start haproxy
```
Kết quả: VM1 sẽ thực hiện quyền "Preempt" (Chiếm lại quyền ưu tiên), IP .100 sẽ nhảy từ VM2 quay về VM1.





